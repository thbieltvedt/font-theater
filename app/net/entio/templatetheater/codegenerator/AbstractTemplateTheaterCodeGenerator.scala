package net.entio.templatetheater.codegenerator

import scala.collection.Map
import scala.collection.Set
import scala.collection.Traversable
import scala.collection.immutable
import scala.collection.mutable.Stack
import org.fusesource.scalate.Binding
import org.fusesource.scalate.Template
import org.fusesource.scalate.TemplateEngine
import org.fusesource.scalate.TemplateSource
import org.fusesource.scalate.ssp.PageFragment
import org.fusesource.scalate.support.Code
import net.entio.templatetheater.codegenerator.parser.MacroFragment
import net.entio.templatetheater.codegenerator.parser.TplParser
import net.entio.templatetheater.codegenerator.parser.UseFragment
import net.entio.templatetheater.codegenerator.parser.UseFragment

protected[codegenerator] class AbstractTemplateTheaterCodeGenerator extends ModifiedSspCodeGenerator {
  override val parser = new TplParser
  protected def createSourceBuilder(useFragmentToClassNameMap: UseFragmentToClassNameMap): SourceBuilder =
    new TemplateTheaterSourceBuilder(useFragmentToClassNameMap)

  private type TuplePageFragmentListAndStringSet = (List[PageFragment], Set[String])
  protected type UseFragmentToClassNameMap = Map[UseFragment, String]

  override def generate(engine: TemplateEngine, source: TemplateSource, bindings: Traversable[Binding]): Code = {
    val sourceFragments: List[PageFragment] = toFragments(source)

    val useFragments: List[UseFragment] = resolveUseFragments(sourceFragments)
    val useFragmentToClassNameMap: UseFragmentToClassNameMap =
      loadUseDependencies(useFragments: List[UseFragment], engine: TemplateEngine): Map[UseFragment, String]

    val dependencyUris: immutable.Set[String] = immutable.Set(source.uri) ++ useFragmentToClassNameMap.keySet.map(_.uri.value)

    val sourceBuilder = createSourceBuilder(useFragmentToClassNameMap)
    sourceBuilder.generate(engine, source, bindings, sourceFragments)

    val code = Code(source.className, sourceBuilder.code, dependencyUris, sourceBuilder.positions)
    
    code
  }

  override protected def checkSyntax(fragment: PageFragment, open: Open, expect: Expect, endStack: Stack[PageFragment]) {
    fragment match {
      case fragment: UseFragment => // Do nothing
      case fragment: MacroFragment => open(fragment)
      case _ => super.checkSyntax(fragment, open, expect, endStack)
    }
  }

  private def resolveUseFragments(fragments: List[PageFragment]): List[UseFragment] = {
    for (fragment <- fragments if (fragment.isInstanceOf[UseFragment]))
      yield fragment.asInstanceOf[UseFragment]
  }

  private def loadUseDependencies(useFragments: List[UseFragment], engine: TemplateEngine): UseFragmentToClassNameMap = {
    val classNameMap = collection.mutable.Map[UseFragment, String]()

    useFragments.foreach { useFragment =>
      val template: Template = engine.load(useFragment.uri)
      classNameMap.put(useFragment, template.source.className)
    }

    classNameMap
  }

  protected class TemplateTheaterSourceBuilder(useFragmentToClassNameMap: UseFragmentToClassNameMap) extends SourceBuilder {
    override def generate(fragment: PageFragment) {
      fragment match {
        case MacroFragment(name, code) => {
          this << "def " + name + "(" + code + ") {" :: Nil
          indentLevel += 1
        }
        case UseFragment(uri, asIdentifier) => {
          // Prefixing className with _root_ to allow asIdentifier to have same value as name of the class' root package:
          val className: String = "_root_." + useFragmentToClassNameMap.get(UseFragment(uri, asIdentifier)).get
          this << " def " + asIdentifier + " = " + className + ".init(context)" :: Nil
          indentLevel += 1
        }
        case _ => {
          super.generate(fragment)
        }
      }
    }

    override def generate(engine: TemplateEngine, source: TemplateSource, bindings: Traversable[Binding], statements: List[PageFragment]) {
      val packageName = source.packageName
      val className = source.simpleClassName

      this << "/* NOTE this file is autogenerated. */"
      if (packageName != "") {
        this << "package " + packageName
      }

      this << ""

      val engineImports = engine.importStatements
      for (i <- engineImports) {
        this << i
      }
      if (!engineImports.isEmpty) {
        this << ""
      }

      this << "object " + className + " {"
      this << "   def init(context: _root_.org.fusesource.scalate.RenderContext) = new " + className + "$real" + "(context)"
      this << "}"
      this <<;
      this <<;
      this << "class " + className + " extends _root_.org.fusesource.scalate.Template {"
      indent {
        this << "def render(context: _root_.org.fusesource.scalate.RenderContext) {"
        this << "   " + className + ".init(context) "
        this << "}"
      }
      this << "}"
      this <<;
      this <<;
      this << "class " + className + "$real" + "($_scalate_$_context: _root_.org.fusesource.scalate.RenderContext) {"
      indent {
        generateInitialImports
        generateBindings(bindings) {
          generateTemplatePackage(source, bindings)

          generate(statements)
          if (statements.isEmpty) {
            // lets generate a dummy statement to avoid a compile error
            this << "$_scalate_$_context << \"\""
          }
        }
      }
      this << "}"
    }
    
    override def generateBindings(bindings: Traversable[Binding])(body: => Unit): Unit = {
      bindings.foreach(arg => {
//        this << ";{"
//        indentLevel += 1
        generateBinding(arg)
      })

      body

      bindings.foreach(arg => {
//        indentLevel -= 1
//        this << "}"
      })
    }

  }
  
}